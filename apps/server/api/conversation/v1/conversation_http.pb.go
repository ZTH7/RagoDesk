// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             (unknown)
// source: api/conversation/v1/conversation.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationConversationCloseSession = "/api.conversation.v1.Conversation/CloseSession"
const OperationConversationCreateFeedback = "/api.conversation.v1.Conversation/CreateFeedback"
const OperationConversationCreateSession = "/api.conversation.v1.Conversation/CreateSession"
const OperationConversationGetSession = "/api.conversation.v1.Conversation/GetSession"

type ConversationHTTPServer interface {
	CloseSession(context.Context, *CloseSessionRequest) (*emptypb.Empty, error)
	CreateFeedback(context.Context, *CreateFeedbackRequest) (*emptypb.Empty, error)
	CreateSession(context.Context, *CreateSessionRequest) (*CreateSessionResponse, error)
	GetSession(context.Context, *GetSessionRequest) (*GetSessionResponse, error)
}

func RegisterConversationHTTPServer(s *http.Server, srv ConversationHTTPServer) {
	r := s.Route("/")
	r.POST("/api/v1/session", _Conversation_CreateSession0_HTTP_Handler(srv))
	r.GET("/api/v1/session/{session_id}", _Conversation_GetSession0_HTTP_Handler(srv))
	r.POST("/api/v1/session/{session_id}/close", _Conversation_CloseSession0_HTTP_Handler(srv))
	r.POST("/api/v1/feedback", _Conversation_CreateFeedback0_HTTP_Handler(srv))
}

func _Conversation_CreateSession0_HTTP_Handler(srv ConversationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateSessionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationConversationCreateSession)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateSession(ctx, req.(*CreateSessionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateSessionResponse)
		return ctx.Result(200, reply)
	}
}

func _Conversation_GetSession0_HTTP_Handler(srv ConversationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetSessionRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationConversationGetSession)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetSession(ctx, req.(*GetSessionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetSessionResponse)
		return ctx.Result(200, reply)
	}
}

func _Conversation_CloseSession0_HTTP_Handler(srv ConversationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CloseSessionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationConversationCloseSession)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CloseSession(ctx, req.(*CloseSessionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _Conversation_CreateFeedback0_HTTP_Handler(srv ConversationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateFeedbackRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationConversationCreateFeedback)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateFeedback(ctx, req.(*CreateFeedbackRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

type ConversationHTTPClient interface {
	CloseSession(ctx context.Context, req *CloseSessionRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	CreateFeedback(ctx context.Context, req *CreateFeedbackRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	CreateSession(ctx context.Context, req *CreateSessionRequest, opts ...http.CallOption) (rsp *CreateSessionResponse, err error)
	GetSession(ctx context.Context, req *GetSessionRequest, opts ...http.CallOption) (rsp *GetSessionResponse, err error)
}

type ConversationHTTPClientImpl struct {
	cc *http.Client
}

func NewConversationHTTPClient(client *http.Client) ConversationHTTPClient {
	return &ConversationHTTPClientImpl{client}
}

func (c *ConversationHTTPClientImpl) CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/api/v1/session/{session_id}/close"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationConversationCloseSession))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ConversationHTTPClientImpl) CreateFeedback(ctx context.Context, in *CreateFeedbackRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/api/v1/feedback"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationConversationCreateFeedback))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ConversationHTTPClientImpl) CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...http.CallOption) (*CreateSessionResponse, error) {
	var out CreateSessionResponse
	pattern := "/api/v1/session"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationConversationCreateSession))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ConversationHTTPClientImpl) GetSession(ctx context.Context, in *GetSessionRequest, opts ...http.CallOption) (*GetSessionResponse, error) {
	var out GetSessionResponse
	pattern := "/api/v1/session/{session_id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationConversationGetSession))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

const OperationConsoleConversationListMessages = "/api.conversation.v1.ConsoleConversation/ListMessages"
const OperationConsoleConversationListSessions = "/api.conversation.v1.ConsoleConversation/ListSessions"

type ConsoleConversationHTTPServer interface {
	ListMessages(context.Context, *ListMessagesRequest) (*ListMessagesResponse, error)
	ListSessions(context.Context, *ListSessionsRequest) (*ListSessionsResponse, error)
}

func RegisterConsoleConversationHTTPServer(s *http.Server, srv ConsoleConversationHTTPServer) {
	r := s.Route("/")
	r.GET("/console/v1/sessions", _ConsoleConversation_ListSessions0_HTTP_Handler(srv))
	r.GET("/console/v1/sessions/{session_id}/messages", _ConsoleConversation_ListMessages0_HTTP_Handler(srv))
}

func _ConsoleConversation_ListSessions0_HTTP_Handler(srv ConsoleConversationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListSessionsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationConsoleConversationListSessions)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListSessions(ctx, req.(*ListSessionsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListSessionsResponse)
		return ctx.Result(200, reply)
	}
}

func _ConsoleConversation_ListMessages0_HTTP_Handler(srv ConsoleConversationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListMessagesRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationConsoleConversationListMessages)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListMessages(ctx, req.(*ListMessagesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListMessagesResponse)
		return ctx.Result(200, reply)
	}
}

type ConsoleConversationHTTPClient interface {
	ListMessages(ctx context.Context, req *ListMessagesRequest, opts ...http.CallOption) (rsp *ListMessagesResponse, err error)
	ListSessions(ctx context.Context, req *ListSessionsRequest, opts ...http.CallOption) (rsp *ListSessionsResponse, err error)
}

type ConsoleConversationHTTPClientImpl struct {
	cc *http.Client
}

func NewConsoleConversationHTTPClient(client *http.Client) ConsoleConversationHTTPClient {
	return &ConsoleConversationHTTPClientImpl{client}
}

func (c *ConsoleConversationHTTPClientImpl) ListMessages(ctx context.Context, in *ListMessagesRequest, opts ...http.CallOption) (*ListMessagesResponse, error) {
	var out ListMessagesResponse
	pattern := "/console/v1/sessions/{session_id}/messages"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationConsoleConversationListMessages))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ConsoleConversationHTTPClientImpl) ListSessions(ctx context.Context, in *ListSessionsRequest, opts ...http.CallOption) (*ListSessionsResponse, error) {
	var out ListSessionsResponse
	pattern := "/console/v1/sessions"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationConsoleConversationListSessions))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
